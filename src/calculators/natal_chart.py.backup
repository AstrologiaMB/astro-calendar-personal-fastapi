"""
Módulo para el cálculo de cartas natales usando nuestra implementación local de Immanuel.
"""
from datetime import datetime
from typing import Dict, Any
from zoneinfo import ZoneInfo
import immanuel.charts as charts
from immanuel.const import chart
from immanuel.setup import settings

# Configurar objetos a incluir en el cálculo
settings.objects = [
    # Planetas
    chart.SUN, chart.MOON, chart.MERCURY, chart.VENUS, chart.MARS,
    chart.JUPITER, chart.SATURN, chart.URANUS, chart.NEPTUNE, chart.PLUTO,
    # Ángulos
    chart.ASC, chart.MC,
    # Puntos especiales
    chart.TRUE_NORTH_NODE, chart.TRUE_SOUTH_NODE, chart.LILITH, chart.CHIRON,
    chart.PART_OF_FORTUNE, chart.VERTEX
]

def _convertir_formato_carta(natal_data: Dict[str, Any]) -> Dict[str, Any]:
    """
    Convierte el formato de la carta natal de Immanuel al formato esperado por main.py
    """
    result = {
        'points': {},
        'houses': {},
        'angles': {},
        'aspects': [],
        'location': natal_data.get('location', {})
    }
    
    # Convertir objetos
    for index, obj in natal_data.get('objects', {}).items():
        # Extraer datos básicos
        degrees = obj.sign_longitude.raw if hasattr(obj.sign_longitude, 'raw') else obj.sign_longitude
        minutes = obj.sign_longitude.minutes if hasattr(obj.sign_longitude, 'minutes') else 0
        seconds = obj.sign_longitude.seconds if hasattr(obj.sign_longitude, 'seconds') else 0
        
        point_data = {
            'longitude': obj.longitude.raw if hasattr(obj.longitude, 'raw') else obj.longitude,
            'latitude': (obj.latitude.raw if hasattr(obj.latitude, 'raw') else obj.latitude) if hasattr(obj, 'latitude') else 0.0,
            'distance': (obj.distance.raw if hasattr(obj.distance, 'raw') else obj.distance) if hasattr(obj, 'distance') else 0.0,
            'sign': obj.sign.name,
            'degrees': degrees,
            'position': f"{int(degrees)}°{minutes:02d}'{seconds:02d}\"",
            'retrograde': obj.movement.retrograde if hasattr(obj, 'movement') and hasattr(obj.movement, 'retrograde') else False
        }
        
        # Usar el nombre del objeto como clave
        result['points'][obj.name] = point_data
        
        # Agregar ángulos
        if obj.name in ['Asc', 'MC']:
            angle_data = {
                'longitude': obj.longitude.raw if hasattr(obj.longitude, 'raw') else obj.longitude,
                'sign': obj.sign.name,
                'degrees': degrees,
                'position': f"{int(degrees)}°{minutes:02d}'{seconds:02d}\""
            }
            result['angles'][obj.name] = angle_data
            result['points'][obj.name] = angle_data
            
            # Agregar puntos opuestos (DSC y IC)
            # Agregar puntos opuestos (DSC y IC)
            if obj.name == 'Asc':
                opposite_name = 'Dsc'
            else:  # MC
                opposite_name = 'Ic'
            # Calcular punto opuesto
            base_longitude = obj.longitude.raw if hasattr(obj.longitude, 'raw') else obj.longitude
            opposite_longitude = (base_longitude + 180) % 360
            opposite_sign_index = int(opposite_longitude / 30)
            opposite_sign = ['Aries', 'Tauro', 'Géminis', 'Cáncer', 'Leo', 'Virgo', 
                           'Libra', 'Escorpio', 'Sagitario', 'Capricornio', 'Acuario', 'Piscis'][opposite_sign_index]
            opposite_sign_longitude = opposite_longitude % 30
            
            # Extraer minutos y segundos del punto original
            minutes = obj.sign_longitude.minutes if hasattr(obj.sign_longitude, 'minutes') else 0
            seconds = obj.sign_longitude.seconds if hasattr(obj.sign_longitude, 'seconds') else 0
            
            opposite_data = {
                'longitude': opposite_longitude,
                'sign': opposite_sign,
                'degrees': opposite_sign_longitude,
                'position': f"{int(opposite_sign_longitude)}°{minutes:02d}'{seconds:02d}\""
            }
            result['angles'][opposite_name] = opposite_data
            result['points'][opposite_name] = opposite_data
    
    # Convertir casas
    for index, house in natal_data.get('houses', {}).items():
        degrees = house.sign_longitude.raw if hasattr(house.sign_longitude, 'raw') else house.sign_longitude
        minutes = house.sign_longitude.minutes if hasattr(house.sign_longitude, 'minutes') else 0
        seconds = house.sign_longitude.seconds if hasattr(house.sign_longitude, 'seconds') else 0
        
        result['houses'][str(house.number)] = {
            'longitude': house.longitude.raw if hasattr(house.longitude, 'raw') else house.longitude,
            'sign': house.sign.name,
            'degrees': degrees,
            'position': f"{int(degrees)}°{minutes:02d}'{seconds:02d}\""
        }
    
    # Calcular aspectos
    planets = ['Sun', 'Moon', 'Mercury', 'Venus', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune', 'Pluto']
    aspects = {
        0: ('Conjunción', 10),
        60: ('Sextil', 6),
        90: ('Cuadratura', 10),
        120: ('Trígono', 10),
        180: ('Oposición', 10)
    }
    
    for i, p1 in enumerate(planets):
        if p1 not in result['points']:
            continue
        for p2 in planets[i+1:]:
            if p2 not in result['points']:
                continue
                
            # Calcular diferencia angular
            diff = abs(result['points'][p1]['longitude'] - result['points'][p2]['longitude'])
            if diff > 180:
                diff = 360 - diff
                
            # Verificar aspectos
            for angle, (aspect_name, max_orb) in aspects.items():
                orb = abs(diff - angle)
                if orb <= max_orb:
                    result['aspects'].append({
                        'point1': p1,
                        'point2': p2,
                        'aspect': aspect_name,
                        'orb': orb
                    })
    
    return result

def calcular_carta_natal(datos_usuario: Dict[str, Any]) -> Dict[str, Any]:
    """
    Función principal para calcular una carta natal usando Immanuel.
    
    Args:
        datos_usuario: Diccionario con los datos del usuario:
            - hora_local: str (formato ISO)
            - lat: float
            - lon: float
            - zona_horaria: str
            
    Returns:
        Dict con la carta natal calculada
    """
    try:
        # Usar coordenadas directamente
        latitude = datos_usuario['lat']
        longitude = datos_usuario['lon']
        
        # Usar tiempo local directamente como hace cartaimmanuel
        local_time = datetime.fromisoformat(datos_usuario['hora_local'])
        
        # Crear sujeto para la carta natal
        native = charts.Subject(
            date_time=local_time,
            latitude=latitude,
            longitude=longitude
        )
        
        # Calcular carta natal usando Immanuel
        natal_chart = charts.Natal(native)
        raw_data = {
            'objects': natal_chart.objects,
            'houses': natal_chart.houses
        }
        
        # Agregar información de ubicación
        raw_data['location'] = {
            'latitude': datos_usuario['lat'],
            'longitude': datos_usuario['lon'],
            'name': datos_usuario.get('lugar', 'Unknown'),
            'timezone': datos_usuario['zona_horaria']
        }
        
        # Convertir al formato esperado
        result = _convertir_formato_carta(raw_data)
        
        # Agregar la fecha de nacimiento al resultado
        # Esto es necesario para el cálculo de la Luna progresada
        result['hora_local'] = datos_usuario['hora_local']
        
        return result
        
    except Exception as e:
        import traceback
        error_details = traceback.format_exc()
        print(f"Error detallado:\n{error_details}")
        raise ValueError(f"Error calculando carta natal: {str(e)}")
